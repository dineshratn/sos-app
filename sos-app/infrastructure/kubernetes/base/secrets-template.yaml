# =============================================================================
# SOS App - Kubernetes Secrets Template
# =============================================================================
# Purpose: Define secret placeholders for secure credential management
# Security: This is a TEMPLATE only - DO NOT commit actual secrets to Git
# Usage: Copy this file, populate with real values, apply to cluster
# =============================================================================

# ⚠️  SECURITY WARNING  ⚠️
#
# This file contains PLACEHOLDER values only.
# DO NOT commit actual secrets to version control!
#
# To use this template:
# 1. Copy this file: cp secrets-template.yaml secrets.yaml
# 2. Add secrets.yaml to .gitignore
# 3. Replace all <PLACEHOLDER> values with actual secrets
# 4. Base64 encode all secret values: echo -n "value" | base64
# 5. Apply to cluster: kubectl apply -f secrets.yaml
# 6. Delete local secrets.yaml file for security
#
# Better approach: Use external secret management:
# - AWS Secrets Manager + External Secrets Operator
# - GCP Secret Manager + External Secrets Operator
# - Azure Key Vault + External Secrets Operator
# - HashiCorp Vault
# - Sealed Secrets (for GitOps)
#
# =============================================================================

---
# -----------------------------------------------------------------------------
# Secret: PostgreSQL Database Credentials
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: postgres-credentials
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: database
    secret-type: database
  annotations:
    description: "PostgreSQL database credentials"
type: Opaque
data:
  # Postgres superuser credentials
  postgres-password: <BASE64_ENCODED_PASSWORD>
  # Example: echo -n 'your-strong-password' | base64

  # Database-specific credentials
  auth-db-username: <BASE64_ENCODED_USERNAME>
  auth-db-password: <BASE64_ENCODED_PASSWORD>

  users-db-username: <BASE64_ENCODED_USERNAME>
  users-db-password: <BASE64_ENCODED_PASSWORD>

  emergency-db-username: <BASE64_ENCODED_USERNAME>
  emergency-db-password: <BASE64_ENCODED_PASSWORD>

  medical-db-username: <BASE64_ENCODED_USERNAME>
  medical-db-password: <BASE64_ENCODED_PASSWORD>

  devices-db-username: <BASE64_ENCODED_USERNAME>
  devices-db-password: <BASE64_ENCODED_PASSWORD>

# Example with actual base64 values (DO NOT USE IN PRODUCTION):
# postgres-password: cGFzc3dvcmQxMjM=  # "password123"
# auth-db-username: YXV0aF91c2Vy        # "auth_user"
# auth-db-password: YXV0aF9wYXNzMTIz    # "auth_pass123"

---
# -----------------------------------------------------------------------------
# Secret: TimescaleDB Database Credentials
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: timescale-credentials
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: database
    secret-type: database
  annotations:
    description: "TimescaleDB database credentials"
type: Opaque
data:
  # TimescaleDB superuser credentials
  timescale-password: <BASE64_ENCODED_PASSWORD>
  # Example: echo -n 'your-strong-password' | base64

  # Location service credentials
  location-db-username: <BASE64_ENCODED_USERNAME>
  location-db-password: <BASE64_ENCODED_PASSWORD>

---
# -----------------------------------------------------------------------------
# Secret: MongoDB Database Credentials
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: mongodb-credentials
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: database
    secret-type: database
type: Opaque
data:
  # MongoDB root credentials
  mongodb-root-username: <BASE64_ENCODED_USERNAME>
  mongodb-root-password: <BASE64_ENCODED_PASSWORD>

  # Application credentials
  mongodb-username: <BASE64_ENCODED_USERNAME>
  mongodb-password: <BASE64_ENCODED_PASSWORD>

  # Replica set key (for authentication between replica set members)
  mongodb-replica-set-key: <BASE64_ENCODED_KEY>
  # Generate with: openssl rand -base64 756

---
# -----------------------------------------------------------------------------
# Secret: Redis Credentials
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: redis-credentials
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: cache
    secret-type: database
type: Opaque
data:
  # Redis password
  redis-password: <BASE64_ENCODED_PASSWORD>

  # Redis Pub/Sub password (can be same or different)
  redis-pubsub-password: <BASE64_ENCODED_PASSWORD>

---
# -----------------------------------------------------------------------------
# Secret: JWT Secrets
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: jwt-secrets
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: auth
    secret-type: jwt
type: Opaque
data:
  # JWT signing keys (use strong random strings)
  jwt-secret: <BASE64_ENCODED_SECRET>
  # Generate with: openssl rand -base64 64

  jwt-refresh-secret: <BASE64_ENCODED_SECRET>
  # Generate with: openssl rand -base64 64

  # JWT RSA keys (for RS256 algorithm - more secure than HS256)
  jwt-private-key: <BASE64_ENCODED_PRIVATE_KEY>
  # Generate with: openssl genrsa -out private.pem 2048 && base64 private.pem

  jwt-public-key: <BASE64_ENCODED_PUBLIC_KEY>
  # Generate with: openssl rsa -in private.pem -pubout -out public.pem && base64 public.pem

---
# -----------------------------------------------------------------------------
# Secret: Encryption Keys (for HIPAA compliance)
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: encryption-keys
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: security
    secret-type: encryption
  annotations:
    description: "Encryption keys for sensitive data (medical records, PII)"
type: Opaque
data:
  # AES-256 encryption key for medical records
  medical-encryption-key: <BASE64_ENCODED_KEY>
  # Generate with: openssl rand -base64 32

  # AES-256 encryption key for PII
  pii-encryption-key: <BASE64_ENCODED_KEY>
  # Generate with: openssl rand -base64 32

  # Data encryption key (DEK)
  data-encryption-key: <BASE64_ENCODED_KEY>

  # Key encryption key (KEK) - for envelope encryption
  key-encryption-key: <BASE64_ENCODED_KEY>

---
# -----------------------------------------------------------------------------
# Secret: External API Keys
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: external-api-keys
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: external-apis
    secret-type: api-keys
type: Opaque
data:
  # Google Maps API Key
  google-maps-api-key: <BASE64_ENCODED_API_KEY>

  # Google Cloud Speech-to-Text API Key
  google-speech-api-key: <BASE64_ENCODED_API_KEY>

  # Twilio API Keys (SMS/Voice)
  twilio-account-sid: <BASE64_ENCODED_SID>
  twilio-auth-token: <BASE64_ENCODED_TOKEN>
  twilio-phone-number: <BASE64_ENCODED_PHONE>

  # Firebase Cloud Messaging (Push Notifications)
  fcm-server-key: <BASE64_ENCODED_KEY>
  fcm-sender-id: <BASE64_ENCODED_SENDER_ID>

  # Apple Push Notification Service (APNS)
  apns-key-id: <BASE64_ENCODED_KEY_ID>
  apns-team-id: <BASE64_ENCODED_TEAM_ID>
  apns-auth-key: <BASE64_ENCODED_AUTH_KEY>

  # SendGrid API Key (Email)
  sendgrid-api-key: <BASE64_ENCODED_API_KEY>

  # AWS API Keys (if using AWS services)
  aws-access-key-id: <BASE64_ENCODED_ACCESS_KEY>
  aws-secret-access-key: <BASE64_ENCODED_SECRET_KEY>

---
# -----------------------------------------------------------------------------
# Secret: OAuth Credentials
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: oauth-credentials
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: auth
    secret-type: oauth
type: Opaque
data:
  # Google OAuth
  google-client-id: <BASE64_ENCODED_CLIENT_ID>
  google-client-secret: <BASE64_ENCODED_CLIENT_SECRET>

  # Apple OAuth
  apple-client-id: <BASE64_ENCODED_CLIENT_ID>
  apple-team-id: <BASE64_ENCODED_TEAM_ID>
  apple-key-id: <BASE64_ENCODED_KEY_ID>
  apple-private-key: <BASE64_ENCODED_PRIVATE_KEY>

  # Facebook OAuth (if enabled)
  facebook-app-id: <BASE64_ENCODED_APP_ID>
  facebook-app-secret: <BASE64_ENCODED_APP_SECRET>

---
# -----------------------------------------------------------------------------
# Secret: S3/Object Storage Credentials
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: object-storage-credentials
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: storage
    secret-type: storage
type: Opaque
data:
  # AWS S3
  s3-access-key-id: <BASE64_ENCODED_ACCESS_KEY>
  s3-secret-access-key: <BASE64_ENCODED_SECRET_KEY>
  s3-bucket-name: <BASE64_ENCODED_BUCKET_NAME>
  s3-region: <BASE64_ENCODED_REGION>

  # Or GCP Cloud Storage
  gcs-service-account-key: <BASE64_ENCODED_SERVICE_ACCOUNT_JSON>
  gcs-bucket-name: <BASE64_ENCODED_BUCKET_NAME>

  # Or Azure Blob Storage
  azure-storage-account-name: <BASE64_ENCODED_ACCOUNT_NAME>
  azure-storage-account-key: <BASE64_ENCODED_ACCOUNT_KEY>
  azure-storage-container-name: <BASE64_ENCODED_CONTAINER_NAME>

---
# -----------------------------------------------------------------------------
# Secret: Kafka Credentials
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: kafka-credentials
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: messaging
    secret-type: messaging
type: Opaque
data:
  # Kafka SASL credentials (if using SASL authentication)
  kafka-username: <BASE64_ENCODED_USERNAME>
  kafka-password: <BASE64_ENCODED_PASSWORD>

  # Kafka SSL certificates (if using SSL/TLS)
  kafka-ca-cert: <BASE64_ENCODED_CA_CERT>
  kafka-client-cert: <BASE64_ENCODED_CLIENT_CERT>
  kafka-client-key: <BASE64_ENCODED_CLIENT_KEY>

---
# -----------------------------------------------------------------------------
# Secret: MQTT Broker Credentials
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: mqtt-credentials
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: mqtt
    secret-type: messaging
type: Opaque
data:
  # MQTT broker credentials
  mqtt-username: <BASE64_ENCODED_USERNAME>
  mqtt-password: <BASE64_ENCODED_PASSWORD>

  # MQTT SSL certificates (if using TLS)
  mqtt-ca-cert: <BASE64_ENCODED_CA_CERT>
  mqtt-client-cert: <BASE64_ENCODED_CLIENT_CERT>
  mqtt-client-key: <BASE64_ENCODED_CLIENT_KEY>

---
# -----------------------------------------------------------------------------
# Secret: Kafka Credentials (updated section)
# -----------------------------------------------------------------------------
# Note: Kafka section already exists above, no changes needed for basic setup
# For production, consider adding SASL/SSL authentication

---
# -----------------------------------------------------------------------------
# Secret: Monitoring and APM Credentials
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: monitoring-credentials
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: monitoring
    secret-type: monitoring
type: Opaque
data:
  # Datadog APM
  datadog-api-key: <BASE64_ENCODED_API_KEY>

  # New Relic APM
  newrelic-license-key: <BASE64_ENCODED_LICENSE_KEY>

  # Sentry Error Tracking
  sentry-dsn: <BASE64_ENCODED_DSN>

  # Prometheus remote write credentials
  prometheus-username: <BASE64_ENCODED_USERNAME>
  prometheus-password: <BASE64_ENCODED_PASSWORD>

---
# -----------------------------------------------------------------------------
# Secret: TLS Certificates
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Secret
metadata:
  name: tls-certificates
  namespace: sos-app
  labels:
    app.kubernetes.io/name: sos-app
    app.kubernetes.io/component: networking
    secret-type: tls
type: kubernetes.io/tls
data:
  # TLS certificate and key for HTTPS
  tls.crt: <BASE64_ENCODED_CERTIFICATE>
  tls.key: <BASE64_ENCODED_PRIVATE_KEY>

# Generate self-signed certificate for testing:
# openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
#   -keyout tls.key -out tls.crt \
#   -subj "/CN=sos-app.example.com/O=SOS App"

# Or use cert-manager for automatic certificate management with Let's Encrypt

# =============================================================================
# Secret Generation Commands
# =============================================================================
#
# Generate random password:
#   openssl rand -base64 32
#
# Generate JWT secret:
#   openssl rand -base64 64
#
# Generate RSA key pair:
#   openssl genrsa -out private.pem 2048
#   openssl rsa -in private.pem -pubout -out public.pem
#
# Base64 encode a value:
#   echo -n 'your-secret-value' | base64
#
# Base64 decode a value:
#   echo 'base64-encoded-value' | base64 -d
#
# Create secret from file:
#   kubectl create secret generic my-secret \
#     --from-file=key=./path/to/file \
#     -n sos-app
#
# Create secret from literal:
#   kubectl create secret generic my-secret \
#     --from-literal=password=mypassword \
#     -n sos-app
#
# =============================================================================
# Using Secrets in Pods
# =============================================================================
#
# Method 1: Environment variables from all keys in secret
#   envFrom:
#   - secretRef:
#       name: postgres-credentials
#
# Method 2: Specific environment variable from secret key
#   env:
#   - name: DATABASE_PASSWORD
#     valueFrom:
#       secretKeyRef:
#         name: postgres-credentials
#         key: postgres-password
#
# Method 3: Mount secret as volume (for certificates, config files)
#   volumes:
#   - name: tls-certs
#     secret:
#       secretName: tls-certificates
#   volumeMounts:
#   - name: tls-certs
#     mountPath: /etc/tls
#     readOnly: true
#
# =============================================================================
# External Secret Management (Recommended for Production)
# =============================================================================
#
# AWS Secrets Manager + External Secrets Operator:
#   apiVersion: external-secrets.io/v1beta1
#   kind: ExternalSecret
#   metadata:
#     name: postgres-credentials
#   spec:
#     secretStoreRef:
#       name: aws-secrets-manager
#     target:
#       name: postgres-credentials
#     data:
#     - secretKey: postgres-password
#       remoteRef:
#         key: sos-app/postgres/password
#
# GCP Secret Manager + External Secrets Operator:
#   apiVersion: external-secrets.io/v1beta1
#   kind: ExternalSecret
#   metadata:
#     name: postgres-credentials
#   spec:
#     secretStoreRef:
#       name: gcp-secret-manager
#     target:
#       name: postgres-credentials
#     data:
#     - secretKey: postgres-password
#       remoteRef:
#         key: sos-app-postgres-password
#
# Sealed Secrets (for GitOps):
#   kubeseal --format yaml < secrets.yaml > sealed-secrets.yaml
#   # Commit sealed-secrets.yaml to Git
#   # Controller decrypts in cluster
#
# =============================================================================
# Security Best Practices
# =============================================================================
#
# 1. Never commit actual secrets to Git
#    - Add secrets*.yaml to .gitignore
#    - Use template files only
#
# 2. Use external secret management
#    - AWS Secrets Manager
#    - GCP Secret Manager
#    - Azure Key Vault
#    - HashiCorp Vault
#
# 3. Rotate secrets regularly
#    - Database passwords: every 90 days
#    - API keys: every 90 days
#    - JWT secrets: every 180 days
#    - Encryption keys: yearly
#
# 4. Use strong random values
#    - Minimum 32 characters for passwords
#    - Minimum 64 characters for JWT secrets
#    - Use openssl rand for generation
#
# 5. Limit secret access with RBAC
#    - Grant only necessary permissions
#    - Use service accounts with minimal privileges
#
# 6. Enable audit logging
#    - Log all secret access
#    - Monitor for unauthorized access
#
# 7. Encrypt secrets at rest
#    - Enable encryption provider in Kubernetes
#    - Use cloud provider KMS
#
# 8. Use separate secrets per environment
#    - Different secrets for dev, staging, production
#    - Never reuse production secrets
#
# =============================================================================
